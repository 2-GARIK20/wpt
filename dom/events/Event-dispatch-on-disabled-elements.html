<!doctype html>
<meta charset="utf8">
<title>Events must dispatch on disabled elements</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<body>
<script>
// HTML elements that can be disabled
const formElements = ["button", "fieldset", "input", "select", "textarea"];

test(() => {
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    // pass becomes true if the event is called and it's the right type.
    let pass = false;
    const listener = ({ type }) => {
      pass = type === "click";
    };
    elem.addEventListener("click", listener, { once: true });
    elem.dispatchEvent(new Event("click"));
    assert_true(
      pass,
      `Untrusted "click" Event didn't dispatch on ${elem.constructor.name}.`
    );
  }
}, "Can dispatch untrusted 'click' Events at disabled HTML elements.");

test(() => {
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    // pass becomes true if the event is called and it's the right type.
    let pass = false;
    const listener = ({ type }) => {
      pass = type === "pass";
    };
    elem.addEventListener("pass", listener, { once: true });
    elem.dispatchEvent(new Event("pass"));
    assert_true(
      pass,
      `Untrusted "pass" Event didn't dispatch on ${elem.constructor.name}`
    );
  }
}, "Can dispatch untrusted Events at disabled HTML elements.");

test(() => {
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    // pass becomes true if the event is called and it's the right type.
    let pass = false;
    const listener = ({ type }) => {
      pass = type === "custom-pass";
    };
    elem.addEventListener("custom-pass", listener, { once: true });
    elem.dispatchEvent(new CustomEvent("custom-pass"));
    assert_true(
      pass,
      `CustomEvent "custom-pass" didn't dispatch on ${elem.constructor.name}`
    );
  }
}, "Can dispatch CustomEvents at disabled HTML elements.");

test(() => {
  for (const localName of formElements) {
    const elem = document.createElement(localName);

    // Element is disabled... so this click() MUST NOT fire an event.
    elem.disabled = true;
    let pass = true;
    elem.onclick = e => {
      pass = false;
    };
    elem.click();
    assert_true(
      pass,
      `.click() must not dispatch "click" event on disabled ${
        elem.constructor.name
      }.`
    );

    // Element is (re)enabled... so this click() fires an event.
    elem.disabled = false;
    pass = false;
    elem.onclick = e => {
      pass = true;
    };
    elem.click();
    assert_true(
      pass,
      `.click() must dispatch "click" event on enabled ${
        elem.constructor.name
      }.`
    );
  }
}, "Calling click() on disabled elements must not dispatch events.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = [
    "drag",
    "dragend",
    "dragenter",
    "dragexit",
    "dragleave",
    "dragover",
    "dragstart",
    "drop",
  ];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new DragEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive ${
        DragEvent.name
      } of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from DragEvent must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = [
    "abort",
    "cancel",
    "canplay",
    "canplaythrough",
    "change",
    "close",
    "cuechange",
    "durationchange",
    "emptied",
    "ended",
    "input",
    "invalid",
    "loadeddata",
    "loadedmetadata",
    "loadend",
    "pause",
    "play",
    "playing",
    "progress",
    "ratechange",
    "reset",
    "securitypolicyviolation",
    "seeked",
    "seeking",
    "select",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "toggle",
    "volumechange",
    "waiting",
  ];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new CustomEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive Event of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from Event interface must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = ["formdata"];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new FormDataEvent(type, { formData: new FormData() }));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive FormDataEvent of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from FormDataEvent must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = ["keydown", "keypress", "keyup"];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new KeyboardEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive KeyboardEvent of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from KeyboardEvent must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = ["loadend", "loadstart"];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new ProgressEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive ProgressEvent of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from ProgressEvent must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = ["wheel"];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new WheelEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive WheelEvent of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from WheelEvent must dispatch on disabled form elements.");

promise_test(async () => {
  // Based on GlobalEventHandlers and mixins
  // https://html.spec.whatwg.org/multipage/webappapis.html#globaleventhandlers
  const eventTypes = [
    "auxclick",
    "contextmenu",
    "dblclick",
    "mousedown",
    "mouseenter",
    "mouseleave",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
  ];
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);
    // Each event type.
    for (const type of eventTypes) {
      let listenerFired = false;
      elem.addEventListener(type, function f() {
        listenerFired = true;
        elem.removeEventListener(type, f);
      });
      let handlerFired = false;
      const handlerAttrName = `on${type}`;
      elem[handlerAttrName] = () => {
        handlerFired = true;
        elem[handlerAttrName] = undefined;
      };
      elem.dispatchEvent(new MouseEvent(type));

      // Generate expectation message.
      const { name: constructorName } = Object.getPrototypeOf(elem).constructor;
      const msg = `on disabled ${constructorName} to receive MouseEvent of type "${type}".`;
      //See how it went...
      assert_true(listenerFired, `Expected listener ${msg}`);
      assert_true(handlerFired, `Expected handler ${msg}`);
    }
    elem.remove();
  }
}, "Events from MouseEvent must dispatch on disabled form elements.");

promise_test(async () => {
  for (const localName of formElements) {
    const elem = document.createElement(localName);
    elem.disabled = true;
    document.body.appendChild(elem);

    // Element is disabled, so clicking must not fire events
    let pass = true;
    elem.onclick = e => {
      pass = false;
    };
    await test_driver.click(elem); // triggers "onclick"
    assert_true(
      pass,
      `${elem.constructor.name} is disabled, so onclick must not fire.`
    );

    // Element is (re)enabled... so this click() will fire an event.
    pass = false;
    elem.disabled = false;
    elem.onclick = () => {
      pass = true;
    };
    await test_driver.click(elem); // triggers "onclick"
    assert_true(
      pass,
      `${elem.constructor.name} is enabled, so onclick must fire.`
    );
    elem.remove();
  }
}, "Real clicks on disabled elements must not dispatch events.");
</script>
